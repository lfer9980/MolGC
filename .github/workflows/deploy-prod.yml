name: CI & Deploy

on:
  push:
    branches:
      - main
      - deploy

env:
  REGISTRY: ghcr.io
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  IMAGE_NAME_BACKEND: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.APP_NAME }}_backend
  IMAGE_NAME_FRONTEND: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.APP_NAME }}_frontend
  IMAGE_NAME_DOCS: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.APP_NAME }}_docs

jobs:
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.PAT }}

      - name: Build & Push Backend Image
        uses: docker/build-push-action@v4
        with:
          context: ./backend
          file: ./backend/Dockerfile.prod
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:latest
          cache-to: type=inline

      - name: Build & Push Frontend Image
        uses: docker/build-push-action@v4
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.prod
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}
          build-args: |
            ${{ secrets.ENV_FRONTEND }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:latest
          cache-to: type=inline

      - name: Build & Push Docs Image
        uses: docker/build-push-action@v4
        with:
          context: ./guidebook
          file: ./guidebook/Dockerfile.prod
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DOCS }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DOCS }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DOCS }}:latest
          cache-to: type=inline

  sqlite-tests:
    name: Fast tests (SQLite, in-memory)
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: Install backend deps
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt
          pip install pytest

      - name: Run fast tests (sqlite in-memory, non-integration)
        run: |
          export DATABASE_URL=sqlite+aiosqlite:///:memory:
          pytest -q -m "not integration"
        working-directory: ./backend

  integration-postgres:
    name: Integration tests (Postgres + migrations)
    needs: build
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U testuser"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=10

    steps:
      - uses: actions/checkout@v3

      - name: Wait for Postgres to be ready
        run: |
          for i in $(seq 1 20); do
            pg_isready -h localhost -p 5432 -U testuser && break || sleep 1
          done
        env:
          PGPASSWORD: testpass

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: Install backend and testing deps
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt
          pip install alembic asyncpg sqlalchemy pytest

      - name: Run Alembic migrations against Postgres
        working-directory: ./backend
        run: |
          alembic -c alembic.ini upgrade head
        env:
          DATABASE_URL: postgresql+asyncpg://testuser:testpass@localhost:5432/testdb

  deploy:
    name: Deploy to VPS
    needs: [integration-postgres]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/deploy'

    steps:
      - uses: actions/checkout@v3

      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.5.4
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add remote host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Copy docker-compose to remote
        run: |
          scp deploy/docker-compose.prod.yml \
            ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${{ secrets.WORK_DIR }}/docker-compose.prod.yml

      - name: Create .env file for remote
        run: |
          echo "${{ secrets.ENV_BACKEND }}" > env_remote.tmp
          echo "GIT_SHA=${{ github.sha }}" >> env_remote.tmp
          echo "REGISTRY=${{ env.REGISTRY }}" >> env_remote.tmp
          echo "IMAGE_NAME_BACKEND=${{ env.IMAGE_NAME_BACKEND }}" >> env_remote.tmp
          echo "IMAGE_NAME_FRONTEND=${{ env.IMAGE_NAME_FRONTEND }}" >> env_remote.tmp
          echo "IMAGE_NAME_DOCS=${{ env.IMAGE_NAME_DOCS }}" >> env_remote.tmp

      - name: Upload .env to remote
        run: |
          scp env_remote.tmp ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${{ secrets.WORK_DIR }}/.env
          rm env_remote.tmp

      - name: Deploy on remote (pull, migrate, up, cleanup)
        run: |
          ssh -T ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'ENDSSH'
            set -e
            cd ${{ secrets.WORK_DIR }}

            # Load environment variables
            export $(cat .env | grep -v '^#' | xargs)

            echo "========================================="
            echo "üöÄ Starting deployment process..."
            echo "========================================="

            # Pull latest images with SHA tags
            echo "üì• Pulling Docker images..."
            docker pull ${REGISTRY}/${IMAGE_NAME_BACKEND}:${{ github.sha }}
            docker pull ${REGISTRY}/${IMAGE_NAME_FRONTEND}:${{ github.sha }}
            docker pull ${REGISTRY}/${IMAGE_NAME_DOCS}:${{ github.sha }}

            # Tag as latest for docker-compose
            echo "üè∑Ô∏è  Tagging images as latest..."
            docker tag ${REGISTRY}/${IMAGE_NAME_BACKEND}:${{ github.sha }} ${REGISTRY}/${IMAGE_NAME_BACKEND}:latest
            docker tag ${REGISTRY}/${IMAGE_NAME_FRONTEND}:${{ github.sha }} ${REGISTRY}/${IMAGE_NAME_FRONTEND}:latest
            docker tag ${REGISTRY}/${IMAGE_NAME_DOCS}:${{ github.sha }} ${REGISTRY}/${IMAGE_NAME_DOCS}:latest

            # Run migrations BEFORE deploying
            echo "========================================="
            echo "üîÑ Running database migrations..."
            echo "========================================="
            
            docker run --rm \
              --add-host host.docker.internal:host-gateway \
              --env-file .env \
              -e elementalback_application__app_env=production \
              -e DATABASE_URL="${DATABASE_URL}" \
              ${REGISTRY}/${IMAGE_NAME_BACKEND}:${{ github.sha }} \
              sh -c "alembic -c /app/alembic.ini upgrade head"

            MIGRATION_EXIT=$?
            if [ $MIGRATION_EXIT -ne 0 ]; then
              echo "‚ùå Migrations failed with exit code $MIGRATION_EXIT"
              echo "üõë Aborting deployment to prevent data corruption"
              exit $MIGRATION_EXIT
            fi
            
            echo "‚úÖ Migrations completed successfully"

            # Deploy services
            echo "========================================="
            echo "üê≥ Deploying services with docker-compose..."
            echo "========================================="
            
            docker compose -f docker-compose.prod.yml up -d --remove-orphans
            
            COMPOSE_EXIT=$?
            if [ $COMPOSE_EXIT -ne 0 ]; then
              echo "‚ùå Docker compose failed with exit code $COMPOSE_EXIT"
              exit $COMPOSE_EXIT
            fi

            echo "‚úÖ Services deployed successfully"

            # Wait for backend health check
            echo "========================================="
            echo "üè• Checking backend health..."
            echo "========================================="
            
            MAX_RETRIES=30
            RETRY_COUNT=0
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if curl -f http://localhost:4005/health > /dev/null 2>&1; then
                echo "‚úÖ Backend is healthy!"
                break
              fi
              
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "‚è≥ Waiting for backend... ($RETRY_COUNT/$MAX_RETRIES)"
              sleep 2
            done

            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "‚ùå Backend health check failed after $MAX_RETRIES attempts"
              echo "üìã Backend logs:"
              docker logs ${APP_NAME}_backend --tail 50
              exit 1
            fi

            # Clean up old images
            echo "========================================="
            echo "üßπ Cleaning up old Docker images..."
            echo "========================================="

            # Keep current SHA and latest, remove others
            REPOS=(
              "${REGISTRY}/${IMAGE_NAME_BACKEND}"
              "${REGISTRY}/${IMAGE_NAME_FRONTEND}"
              "${REGISTRY}/${IMAGE_NAME_DOCS}"
            )

            # Get list of currently running images
            RUNNING_IMAGES=$(docker ps --format '{{.Image}}' | sort -u)

            for REPO in "${REPOS[@]}"; do
              echo "üîç Checking repo: $REPO"
              
              # Get all images for this repo
              docker images --format '{{.Repository}}:{{.Tag}} {{.ID}}' | grep "^${REPO}:" | while read -r IMAGE_TAG IMAGE_ID; do
                # Keep :latest and current SHA
                if [ "$IMAGE_TAG" = "${REPO}:latest" ] || [ "$IMAGE_TAG" = "${REPO}:${{ github.sha }}" ]; then
                  echo "  ‚úì Keeping $IMAGE_TAG"
                  continue
                fi

                # Keep if currently in use
                if echo "$RUNNING_IMAGES" | grep -q "$IMAGE_TAG"; then
                  echo "  ‚ö†Ô∏è  Skipping in-use image: $IMAGE_TAG"
                  continue
                fi

                # Remove old image
                echo "  üóëÔ∏è  Removing old image: $IMAGE_TAG"
                docker rmi "$IMAGE_ID" 2>/dev/null || echo "    ‚ö†Ô∏è  Could not remove $IMAGE_ID (may be in use)"
              done
            done

            # Prune dangling images
            echo "üßπ Pruning dangling images..."
            docker image prune -f

            # Optional: Remove unused volumes (commented by default for safety)
            # echo "üßπ Pruning unused volumes..."
            # docker volume prune -f

            echo "========================================="
            echo "‚úÖ Deployment completed successfully!"
            echo "========================================="
            echo "üìä Current running services:"
            docker compose -f docker-compose.prod.yml ps
          ENDSSH