name: CI & Deploy

on:
  push:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  IMAGE_NAME_BACKEND: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.APP_NAME }}_backend
  IMAGE_NAME_FRONTEND: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.APP_NAME }}_frontend
  IMAGE_NAME_DOCS: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.APP_NAME }}_docs

jobs:
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.PAT }}

      - name: Build & Push Backend Image
        uses: docker/build-push-action@v4
        with:
          context: ./backend
          file: ./backend/Dockerfile.prod
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:latest
          cache-to: type=inline

      - name: Build & Push Frontend Image
        uses: docker/build-push-action@v4
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.prod
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}
          build-args: |
            ${{ secrets.ENV_FRONTEND }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:latest
          cache-to: type=inline

      - name: Build & Push Docs Image
        uses: docker/build-push-action@v4
        with:
          context: ./guidebook
          file: ./guidebook/Dockerfile.prod
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DOCS }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DOCS }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DOCS }}:latest
          cache-to: type=inline

  sqlite-tests:
    name: Fast tests (SQLite, in-memory)
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: Install backend deps
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt
          pip install pytest

      - name: Run fast tests (sqlite in-memory, non-integration)
        run: |
          export DATABASE_URL=sqlite+aiosqlite:///:memory:
          pytest -q -m "not integration"
        working-directory: ./backend

  integration-postgres:
    name: Integration tests (Postgres + migrations)
    needs: build
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U testuser"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=10

    steps:
      - uses: actions/checkout@v3

      - name: Wait for Postgres to be ready
        run: |
          for i in $(seq 1 20); do
            pg_isready -h localhost -p 5432 -U testuser && break || sleep 1
          done
        env:
          PGPASSWORD: testpass

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: Install backend and testing deps
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt
          pip install alembic asyncpg sqlalchemy pytest

      - name: Run Alembic migrations against Postgres
        working-directory: ./backend
        run: |
          alembic -c alembic.ini upgrade head
        env:
          DATABASE_URL: postgresql+asyncpg://testuser:testpass@localhost:5432/testdb

  deploy:
    name: Deploy to VPS
    needs: [integration-postgres]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v3

      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.5.4
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY_DEVOPS }}

      - name: Add remote host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Copy docker-compose to remote
        run: |
          scp docker-compose.prod.yml \
            ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${{ secrets.WORK_DIR }}/${{ secrets.APP_NAME }}/docker-compose.prod.yml

      - name: Create .env file for remote
        run: |
            cat > env_remote.tmp <<'EOF'
            ${{ secrets.ENV_BACKEND }}
            EOF
            echo "GIT_SHA=${{ github.sha }}" >> env_remote.tmp
            echo "REGISTRY=${{ env.REGISTRY }}" >> env_remote.tmp
            echo "IMAGE_NAME_BACKEND=${{ env.IMAGE_NAME_BACKEND }}" >> env_remote.tmp
            echo "IMAGE_NAME_FRONTEND=${{ env.IMAGE_NAME_FRONTEND }}" >> env_remote.tmp
            echo "IMAGE_NAME_DOCS=${{ env.IMAGE_NAME_DOCS }}" >> env_remote.tmp
            echo "APP_NAME=${{ secrets.APP_NAME }}" >> env_remote.tmp

      - name: Upload .env to remote
        run: |
          scp env_remote.tmp ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${{ secrets.WORK_DIR }}/${{ secrets.APP_NAME }}/.env
          rm env_remote.tmp

      - name: Deploy on remote
        run: |
          ssh -T ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'ENDSSH'
            set -e
            
            # Variables from secrets
            APP_NAME="${{ secrets.APP_NAME }}"
            WORK_DIR="${{ secrets.WORK_DIR }}"
            APP_DIR="${WORK_DIR}/${APP_NAME}"
            
            cd "${APP_DIR}"

            # Load environment variables
            export $(cat .env | grep -v '^#' | xargs)

            echo "========================================="
            echo "ğŸš€ Starting secure deployment..."
            echo "========================================="
            echo "App: ${APP_NAME}"
            echo "Directory: ${APP_DIR}"
            echo "User: $(whoami)"
            echo ""

            # Verificar lÃ­mites de recursos del sistema
            echo "ğŸ“Š System resources check:"
            echo "CPU cores: $(nproc)"
            echo "Memory: $(free -h | awk '/^Mem:/ {print $2}')"
            echo "Disk: $(df -h ${APP_DIR} | awk 'NR==2 {print $4 " available"}')"
            echo ""

            # Pull latest images with SHA tags
            echo "ğŸ“¥ Pulling Docker images..."
            docker pull ${REGISTRY}/${IMAGE_NAME_BACKEND}:${{ github.sha }}
            docker pull ${REGISTRY}/${IMAGE_NAME_FRONTEND}:${{ github.sha }}
            docker pull ${REGISTRY}/${IMAGE_NAME_DOCS}:${{ github.sha }}

            # Verificar integridad de imÃ¡genes
            echo "ğŸ” Verifying image digests..."
            docker inspect ${REGISTRY}/${IMAGE_NAME_BACKEND}:${{ github.sha }} --format='{{.Id}}' > /dev/null
            docker inspect ${REGISTRY}/${IMAGE_NAME_FRONTEND}:${{ github.sha }} --format='{{.Id}}' > /dev/null
            docker inspect ${REGISTRY}/${IMAGE_NAME_DOCS}:${{ github.sha }} --format='{{.Id}}' > /dev/null
            echo "âœ… All images verified"
            echo ""

            # Tag as latest for docker-compose
            echo "ğŸ·ï¸  Tagging images as latest..."
            docker tag ${REGISTRY}/${IMAGE_NAME_BACKEND}:${{ github.sha }} ${REGISTRY}/${IMAGE_NAME_BACKEND}:latest
            docker tag ${REGISTRY}/${IMAGE_NAME_FRONTEND}:${{ github.sha }} ${REGISTRY}/${IMAGE_NAME_FRONTEND}:latest
            docker tag ${REGISTRY}/${IMAGE_NAME_DOCS}:${{ github.sha }} ${REGISTRY}/${IMAGE_NAME_DOCS}:latest
            echo ""

            # Deploy services with resource limits
            echo "========================================="
            echo "ğŸ³ Deploying services with docker-compose..."
            echo "========================================="

            docker compose -f docker-compose.prod.yml up -d --remove-orphans

            COMPOSE_EXIT=$?
            if [ $COMPOSE_EXIT -ne 0 ]; then
              echo "âŒ Docker compose failed with exit code $COMPOSE_EXIT"
              exit $COMPOSE_EXIT
            fi

            echo "âœ… Services deployed successfully"
            echo ""

            # Monitoring inicial de recursos
            echo "========================================="
            echo "ğŸ“Š Initial resource usage:"
            echo "========================================="
            docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"
            echo ""

            # Wait for backend health check
            echo "========================================="
            echo "ğŸ¥ Checking backend health..."
            echo "========================================="

            MAX_RETRIES=30
            RETRY_COUNT=0

            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if curl -f http://localhost:4005/api/health > /dev/null 2>&1; then
                echo "âœ… Backend is healthy!"
                break
              fi

              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "â³ Waiting for backend... ($RETRY_COUNT/$MAX_RETRIES)"
              sleep 2
            done

            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "âŒ Backend health check failed after $MAX_RETRIES attempts"
              echo "ğŸ“‹ Backend logs:"
              docker logs ${APP_NAME}_backend --tail 50 || docker logs backend --tail 50 || true
              exit 1
            fi
            echo ""

            # Verificar frontend health
            echo "ğŸ¥ Checking frontend health..."
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if curl -f http://localhost:3005 > /dev/null 2>&1; then
                echo "âœ… Frontend is healthy!"
                break
              fi

              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "â³ Waiting for frontend... ($RETRY_COUNT/$MAX_RETRIES)"
              sleep 2
            done

            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "âš ï¸  Frontend health check timeout (may still be starting)"
            fi
            echo ""

            # Clean up old images
            echo "========================================="
            echo "ğŸ§¹ Cleaning up old Docker images..."
            echo "========================================="

            REPOS=(
              "${REGISTRY}/${IMAGE_NAME_BACKEND}"
              "${REGISTRY}/${IMAGE_NAME_FRONTEND}"
              "${REGISTRY}/${IMAGE_NAME_DOCS}"
            )

            # Get list of currently running images
            RUNNING_IMAGES=$(docker ps --format '{{.Image}}' | sort -u)

            for REPO in "${REPOS[@]}"; do
              echo "ğŸ” Checking repo: $REPO"

              docker images --format '{{.Repository}}:{{.Tag}} {{.ID}}' | grep "^${REPO}:" | while read -r IMAGE_TAG IMAGE_ID; do
                if [ "$IMAGE_TAG" = "${REPO}:latest" ] || [ "$IMAGE_TAG" = "${REPO}:${{ github.sha }}" ]; then
                  echo "  âœ“ Keeping $IMAGE_TAG"
                  continue
                fi

                if echo "$RUNNING_IMAGES" | grep -q "$IMAGE_TAG"; then
                  echo "  âš ï¸  Skipping in-use image: $IMAGE_TAG"
                  continue
                fi

                echo "  ğŸ—‘ï¸  Removing old image: $IMAGE_TAG"
                docker rmi "$IMAGE_ID" 2>/dev/null || echo "    âš ï¸  Could not remove $IMAGE_ID"
              done
            done

            # Prune dangling images
            echo "ğŸ§¹ Pruning dangling images..."
            docker image prune -f
            echo ""

            # Security check: verificar procesos sospechosos
            echo "========================================="
            echo "ğŸ”’ Security checks..."
            echo "========================================="
            
            # Verificar uso de CPU por contenedor
            docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemPerc}}" | while read line; do
              CPU=$(echo $line | awk '{print $2}' | sed 's/%//')
              if [ ! -z "$CPU" ] && [ "$CPU" != "CPU" ]; then
                if [ $(echo "$CPU > 80" | bc -l 2>/dev/null || echo 0) -eq 1 ]; then
                  echo "âš ï¸  HIGH CPU USAGE DETECTED: $line"
                fi
              fi
            done
            echo ""

            echo "========================================="
            echo "âœ… Deployment completed successfully!"
            echo "========================================="
            echo "ğŸ“Š Current running services:"
            docker compose -f docker-compose.prod.yml ps
            echo ""
            
            echo "ğŸ”’ Security measures active:"
            echo "  âœ“ Resource limits enforced"
            echo "  âœ“ Read-only filesystems where possible"
            echo "  âœ“ Capabilities dropped"
            echo "  âœ“ Network isolation"
            echo "  âœ“ Non-privileged containers"
            echo ""
            echo "ğŸ“ App Directory: ${APP_DIR}"
            echo "ğŸ‘¤ Deployed by: $(whoami)"
            echo "ğŸ• Timestamp: $(date)"
          ENDSSH