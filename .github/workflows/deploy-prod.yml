name: CI & Deploy

on:
  push:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  IMAGE_NAME_BACKEND: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.APP_NAME }}_backend
  IMAGE_NAME_FRONTEND: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.APP_NAME }}_frontend
  IMAGE_NAME_DOCS: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.APP_NAME }}_docs

jobs:
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.PAT }}

      - name: Build & Push Backend Image
        uses: docker/build-push-action@v4
        with:
          context: ./backend
          file: ./backend/Dockerfile.prod
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:latest
          cache-to: type=inline

      - name: Build & Push Frontend Image
        uses: docker/build-push-action@v4
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.prod
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}
          build-args: |
            ${{ secrets.ENV_FRONTEND }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:latest
          cache-to: type=inline

      - name: Build & Push Docs Image
        uses: docker/build-push-action@v4
        with:
          context: ./guidebook
          file: ./guidebook/Dockerfile.prod
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DOCS }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DOCS }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DOCS }}:latest
          cache-to: type=inline

  sqlite-tests:
    name: Fast tests (SQLite, in-memory)
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: Install backend deps
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt
          pip install pytest

      - name: Run fast tests (sqlite in-memory, non-integration)
        run: |
          export DATABASE_URL=sqlite+aiosqlite:///:memory:
          pytest -q -m "not integration"
        working-directory: ./backend

  integration-postgres:
    name: Integration tests (Postgres + migrations)
    needs: build
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U testuser"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=10

    steps:
      - uses: actions/checkout@v3

      - name: Wait for Postgres to be ready
        run: |
          for i in $(seq 1 20); do
            pg_isready -h localhost -p 5432 -U testuser && break || sleep 1
          done
        env:
          PGPASSWORD: testpass

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: Install backend and testing deps
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt
          pip install alembic asyncpg sqlalchemy pytest

      - name: Run Alembic migrations against Postgres
        working-directory: ./backend
        run: |
          alembic -c alembic.ini upgrade head
        env:
          DATABASE_URL: postgresql+asyncpg://testuser:testpass@localhost:5432/testdb

  deploy:
    name: Deploy to VPS (Secure)
    needs: [integration-postgres]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v3

      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.5.4
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY_DEPLOYER }}  # Nueva clave del usuario deployer

      - name: Add remote host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Copy docker-compose to remote
        run: |
          scp docker-compose.prod.yml \
            deployer@${{ secrets.SSH_HOST }}:/home/deployer/app/docker-compose.prod.yml

      - name: Create .env file for remote
        run: |
            cat > env_remote.tmp <<'EOF'
            ${{ secrets.ENV_BACKEND }}
            EOF
            echo "GIT_SHA=${{ github.sha }}" >> env_remote.tmp
            echo "REGISTRY=${{ env.REGISTRY }}" >> env_remote.tmp
            echo "IMAGE_NAME_BACKEND=${{ env.IMAGE_NAME_BACKEND }}" >> env_remote.tmp
            echo "IMAGE_NAME_FRONTEND=${{ env.IMAGE_NAME_FRONTEND }}" >> env_remote.tmp
            echo "IMAGE_NAME_DOCS=${{ env.IMAGE_NAME_DOCS }}" >> env_remote.tmp

      - name: Upload .env to remote
        run: |
          scp env_remote.tmp deployer@${{ secrets.SSH_HOST }}:/home/deployer/app/.env
          rm env_remote.tmp

      - name: Deploy on remote (secure deployment)
        run: |
          ssh -T deployer@${{ secrets.SSH_HOST }} << 'ENDSSH'
            set -e
            cd /home/deployer/app

            # Load environment variables
            export $(cat .env | grep -v '^#' | xargs)

            echo "========================================="
            echo "üöÄ Starting secure deployment..."
            echo "========================================="

            # Verificar l√≠mites de recursos del sistema
            echo "üìä System resources check:"
            echo "CPU cores: $(nproc)"
            echo "Memory: $(free -h | awk '/^Mem:/ {print $2}')"
            echo "Disk: $(df -h / | awk 'NR==2 {print $4 " available"}')"

            # Pull latest images with SHA tags
            echo "üì• Pulling Docker images..."
            docker pull ${REGISTRY}/${IMAGE_NAME_BACKEND}:${{ github.sha }}
            docker pull ${REGISTRY}/${IMAGE_NAME_FRONTEND}:${{ github.sha }}
            docker pull ${REGISTRY}/${IMAGE_NAME_DOCS}:${{ github.sha }}

            # Verificar integridad de im√°genes (opcional pero recomendado)
            echo "üîç Verifying image digests..."
            docker inspect ${REGISTRY}/${IMAGE_NAME_BACKEND}:${{ github.sha }} --format='{{.Id}}'
            docker inspect ${REGISTRY}/${IMAGE_NAME_FRONTEND}:${{ github.sha }} --format='{{.Id}}'
            docker inspect ${REGISTRY}/${IMAGE_NAME_DOCS}:${{ github.sha }} --format='{{.Id}}'

            # Tag as latest for docker-compose
            echo "üè∑Ô∏è  Tagging images as latest..."
            docker tag ${REGISTRY}/${IMAGE_NAME_BACKEND}:${{ github.sha }} ${REGISTRY}/${IMAGE_NAME_BACKEND}:latest
            docker tag ${REGISTRY}/${IMAGE_NAME_FRONTEND}:${{ github.sha }} ${REGISTRY}/${IMAGE_NAME_FRONTEND}:latest
            docker tag ${REGISTRY}/${IMAGE_NAME_DOCS}:${{ github.sha }} ${REGISTRY}/${IMAGE_NAME_DOCS}:latest

            # Run migrations BEFORE deploying
            echo "========================================="
            echo "üîÑ Running database migrations..."
            echo "========================================="

            docker run --rm \
              --add-host host.docker.internal:host-gateway \
              --env-file .env \
              -e elementalback_application__app_env=production \
              -e DATABASE_URL="${DATABASE_URL}" \
              --memory="512m" \
              --cpus="0.5" \
              --pids-limit=100 \
              ${REGISTRY}/${IMAGE_NAME_BACKEND}:${{ github.sha }} \
              sh -c "alembic -c /app/alembic.ini upgrade head"

            MIGRATION_EXIT=$?
            if [ $MIGRATION_EXIT -ne 0 ]; then
              echo "‚ùå Migrations failed with exit code $MIGRATION_EXIT"
              echo "üõë Aborting deployment to prevent data corruption"
              exit $MIGRATION_EXIT
            fi

            echo "‚úÖ Migrations completed successfully"

            # Deploy services with resource limits
            echo "========================================="
            echo "üê≥ Deploying services with docker-compose..."
            echo "========================================="

            docker compose -f docker-compose.prod.yml up -d --remove-orphans

            COMPOSE_EXIT=$?
            if [ $COMPOSE_EXIT -ne 0 ]; then
              echo "‚ùå Docker compose failed with exit code $COMPOSE_EXIT"
              exit $COMPOSE_EXIT
            fi

            echo "‚úÖ Services deployed successfully"

            # Monitoring inicial de recursos
            echo "========================================="
            echo "üìä Initial resource usage:"
            echo "========================================="
            docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"

            # Wait for backend health check
            echo "========================================="
            echo "üè• Checking backend health..."
            echo "========================================="

            MAX_RETRIES=30
            RETRY_COUNT=0

            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if curl -f http://localhost:4005/api/health > /dev/null 2>&1; then
                echo "‚úÖ Backend is healthy!"
                break
              fi

              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "‚è≥ Waiting for backend... ($RETRY_COUNT/$MAX_RETRIES)"
              sleep 2
            done

            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "‚ùå Backend health check failed after $MAX_RETRIES attempts"
              echo "üìã Backend logs:"
              docker logs backend --tail 50
              exit 1
            fi

            # Verificar frontend health
            echo "üè• Checking frontend health..."
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if curl -f http://localhost:3005 > /dev/null 2>&1; then
                echo "‚úÖ Frontend is healthy!"
                break
              fi

              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "‚è≥ Waiting for frontend... ($RETRY_COUNT/$MAX_RETRIES)"
              sleep 2
            done

            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "‚ö†Ô∏è  Frontend health check timeout (may still be starting)"
            fi

            # Clean up old images
            echo "========================================="
            echo "üßπ Cleaning up old Docker images..."
            echo "========================================="

            REPOS=(
              "${REGISTRY}/${IMAGE_NAME_BACKEND}"
              "${REGISTRY}/${IMAGE_NAME_FRONTEND}"
              "${REGISTRY}/${IMAGE_NAME_DOCS}"
            )

            # Get list of currently running images
            RUNNING_IMAGES=$(docker ps --format '{{.Image}}' | sort -u)

            for REPO in "${REPOS[@]}"; do
              echo "üîç Checking repo: $REPO"

              docker images --format '{{.Repository}}:{{.Tag}} {{.ID}}' | grep "^${REPO}:" | while read -r IMAGE_TAG IMAGE_ID; do
                if [ "$IMAGE_TAG" = "${REPO}:latest" ] || [ "$IMAGE_TAG" = "${REPO}:${{ github.sha }}" ]; then
                  echo "  ‚úì Keeping $IMAGE_TAG"
                  continue
                fi

                if echo "$RUNNING_IMAGES" | grep -q "$IMAGE_TAG"; then
                  echo "  ‚ö†Ô∏è  Skipping in-use image: $IMAGE_TAG"
                  continue
                fi

                echo "  üóëÔ∏è  Removing old image: $IMAGE_TAG"
                docker rmi "$IMAGE_ID" 2>/dev/null || echo "    ‚ö†Ô∏è  Could not remove $IMAGE_ID"
              done
            done

            # Prune dangling images
            echo "üßπ Pruning dangling images..."
            docker image prune -f

            # Security check: verificar procesos sospechosos
            echo "========================================="
            echo "üîí Security checks..."
            echo "========================================="
            
            # Verificar uso de CPU por contenedor
            docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemPerc}}" | while read line; do
              CPU=$(echo $line | awk '{print $2}' | sed 's/%//')
              if [ ! -z "$CPU" ] && [ "$CPU" != "CPU" ]; then
                if [ $(echo "$CPU > 80" | bc -l 2>/dev/null || echo 0) -eq 1 ]; then
                  echo "‚ö†Ô∏è  HIGH CPU USAGE DETECTED: $line"
                fi
              fi
            done

            echo "========================================="
            echo "‚úÖ Deployment completed successfully!"
            echo "========================================="
            echo "üìä Current running services:"
            docker compose -f docker-compose.prod.yml ps
            
            echo ""
            echo "üîí Security measures active:"
            echo "  ‚úì Resource limits enforced"
            echo "  ‚úì Read-only filesystems where possible"
            echo "  ‚úì Capabilities dropped"
            echo "  ‚úì Network isolation"
            echo "  ‚úì Non-privileged containers"
          ENDSSH